---
title: "R and GIS, or R as GIS: handling spatial data: Representation and visualisation of spatial data"
author: "Roger Bivand"
date: "Tuesday, 27 August 2019, 09:00-10:40; Wolfson Medical School building Gannochy room"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
theme: united
bibliography: Geomed19.bib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

### Copyright

All the material presented here, to the extent it is original, is available under [CC-BY-SA](https://creativecommons.org/licenses/by-sa/4.0/). Parts build on joint tutorials with Edzer Pebesma.

### Required current contributed CRAN packages:


### Script

Script at . Download to suitable location and use as basis.

## Session I

- 09:00-09:30 (20+10) Vector representation: **sf** replaces **sp**, **rgeos** and **rgdal**: vector

- 09:30-10:00 (20+10) Raster representation: **stars**/**sf** replace **sp** and **rgdal**: **raster** remains for now

- 10:00-10:40 (20+20) Visualization: **tmap**, **cartography**, **ggplot2** and **mapview**

## Outline


- Spatial and spatio-temporal data are characterised by structures that distinguish them from typical tabular data

- The geometric structures also have spatial reference system information, and can adhere to standards, which may ease geometrical operations

- Satellite data and numerical model output data typically have regular grid structures, but these are often domain-specific

- Computationally intensive tasks include interpolation, upsampling, focal operations, change of support and handling vector data with very detailed boundaries, as well as modelling using Bayesian inference



## A short history of handling spatial data in R

- pre-2003: several people doing spatial statistics or map manipulation with S-Plus (1996 SpatialStats module), and later R (e.g. spatial in MASS; spatstat, maptools, geoR, splancs, gstat, ...)
- 2003: workshop at [DSC](https://www.r-project.org/conferences/DSC-2003/), concensus that a package with base classes should be useful; this ended up being a multiplicator
- 2003: start of [r-sig-geo](https://stat.ethz.ch/mailman/listinfo/r-sig-geo)
- 2003: [rgdal](https://cran.r-project.org/package=rgdal) released on CRAN (with GDAL and PROJ support)
- 2005: [sp](https://cran.r-project.org/package=sp) released on CRAN; **sp** support in **rgdal**
- 2008: [Applied Spatial Data Analysis with R](https://www.asdar-book.org/)
- 2011: [rgeos](https://cran.r-project.org/package=rgeos) released on CRAN (with GEOS support for **sp** class objects^)
- 2013: second edition of [Applied Spatial Data Analysis with R](https://www.asdar-book.org/) [@asdar]
- 2015 [JSS special issue](https://www.jstatsoft.org/index.php/jss/issue/view/v063)
- 2016-7: **sf** [simple features for R](https://cran.r-project.org/package=sf), R consortium support (combines GDAL, GEOS and PROJ support and S3 classes)
- 2017-9: **stars** [spatiotemporal tidy arrays for R](https://cran.r-project.org/package=stars), R consortium support (considered pretty much "finished"; uses **sf** to interface GDAL)
- 2019 [Geocomputation with R](https://geocompr.robinlovelace.net/) [@geocompr]
- 2020 [Spatial Data Science; uses cases in R](https://r-spatial.org/book) [@sdsr]

## Spatial data

Spatial data typically combine position data in 2D (or 3D), attribute data and metadata related to the position data. Much spatial data could be called map data or GIS data. We collect and handle much more position data since global navigation satellite system (GNSS) like GPS came on stream 20 years ago, earth observation satellites have been providing data for longer. 

\endcol
\begincol{0.48\textwidth}

```{r, echo = TRUE}
library(osmdata)
library(sf)
```
```{r, echo = TRUE, cache=TRUE}
bbox <- opq(bbox = 'bergen norway')
byb0 <- osmdata_sf(add_osm_feature(bbox, key = 'railway',
  value = 'light_rail'))$osm_lines
tram <- osmdata_sf(add_osm_feature(bbox, key = 'railway',
  value = 'tram'))$osm_lines
byb1 <- tram[!is.na(tram$name),]
o <- intersect(names(byb0), names(byb1))
byb <- rbind(byb0[,o], byb1[,o])
```
```{r, echo = TRUE, eval=FALSE}
library(mapview)
mapview(byb)
```


## Vector data

Spatial vector data is based on points, from which other geometries are constructed. Vector data is often also termed object-based spatial data. The light rail tracks are 2D vector data. The points themselves are stored as double precision floating point numbers, typically without recorded measures of accuracy (GNSS provides a measure of accuracy). Here, lines are constructed from points.


```{r, echo = TRUE}
all(st_is(byb, "XY"))
str(st_coordinates(st_geometry(byb)[[1]]))
```



### Representing spatial vector data in R (**sp**)

The **sp** package was a child of its time, using S4 formal classes, and the best compromise we then had of positional representation (not arc-node, but hard to handle holes in polygons). If we coerse `byb` to the **sp** representation, we see the formal class structure. Input/output used OGR/GDAL vector drivers in the **rgdal** package, and topological operations used GEOS in the **rgeos** package.


```{r, echo = TRUE, mysize=TRUE, size='\\tiny'}
library(sp)
str(slot(as(st_geometry(byb), "Spatial"), "lines")[[1]])
```


### Representing spatial vector data in R (**sf**)


The recent **sf** package bundles GDAL and GEOS (**sp** just defined the classes and methods, leaving I/O and computational geometry to other packages). **sf** used `data.frame` objects with one (or more) geometry column for vector data. The representation follows ISO 19125 (*Simple Features*), and has WKT (text) and WKB (binary) representations (used by GDAL and GEOS internally). The drivers include PostGIS and other database constructions permitting selection, and WFS for server APIs (**rgdal** does too, but requires more from the user).


```{r, echo = TRUE, mysize=TRUE, size='\\tiny'}
strwrap(st_as_text(st_geometry(byb)[[1]]))
```


### Simple feature access in R: package `sf`

- Simple feature access is an [ISO standard](http://www.opengeospatial.org/standards/sfa) that is widely adopted. It is used in spatial databases, GIS, open source libraries, GeoJSON, GeoSPARQL, etc.

**sf** uses the OSGEO stack of software:
```{r, echo=TRUE}
sf_extSoftVersion()
```
Internal (R) and system dependencies look like this:
```{r echo=FALSE}
knitr::include_graphics('sf_deps.png')
```


Package **sf** provides handling of feature data, where feature
geometries are points, lines, polygons or combinations of those.
It implements the full set of geometric functions described in the
_simple feature access_ standard, and some. The basic storage is
very simple, and uses only base R types (list, matrix).

* feature sets are held as records (rows) in `"sf"` objects, inheriting from `"data.frame"`
* `"sf"` objects have at least one simple feature geometry list-column of class `"sfc"`
* geometry list-columns are *sticky*, that is they stay stuck to the object when subsetting columns, for example using `[`
* `"sfc"` geometry list-columns have a bounding box and a coordinate reference system as attribute, and a class attribute pointing out the common type (or `"GEOMETRY"` in case of a mix)
* a single simple feature geometry is of class `"sfg"`, and further classes pointing out dimension and type

Storage of simple feature geometry:

* `"POINT"` is a numeric vector
* `"LINESTRING"` and `"MULTIPOINT"` are numeric matrix, points/vertices in rows
* `"POLYGON"` and `"MULTILINESTRING"` are lists of matrices
* `"MULTIPOLYGON"` is a lists of those
* `"GEOMETRYCOLLECTION"` is a list of typed geometries

To build from scratch:
```{r, echo=TRUE}
p1 = st_point(c(3,5))
class(p1)
p2 = st_point(c(4,6))
p3 = st_point(c(4,4))
pts = st_sfc(p1, p2, p3)
class(pts)
sf = st_sf(a = c(3,2.5,4), b = c(1,2,4), geom = pts)
class(sf)
sf
```

### Input/output

```{r, echo=TRUE}
tf <- tempfile(fileext=".gpkg")
st_write(byb, dsn=tf, layer="byb", driver="GPKG")
```

```{r, echo=TRUE}
st_layers(tf)
```


```{r, echo=TRUE}
byb_a <- st_read(tf, layer="byb")
```



```{r, echo=TRUE}
summary(st_length(byb_a))
```



```{r, echo=TRUE}
st_touches(byb_a)
```

## Exercise + review

Try doing this in pairs or small groups and discuss what is going on.

Look at the [North Carolina SIDS data vignette](https://r-spatial.github.io/spdep/articles/sids.html) for background:

```{r, echo=TRUE}
library(sf)
nc <- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
st_crs(nc) <- "+proj=longlat +datum=NAD27"
row.names(nc) <- as.character(nc$FIPSNO)
head(nc)
```

The variables are largely count data, `L_id` and `M_id` are grouping variables. We can also read the original neighbour object:

```{r, echo=TRUE, warning=FALSE}
library(spdep)
gal_file <- system.file("weights/ncCR85.gal", package="spData")[1]
ncCR85 <- read.gal(gal_file, region.id=nc$FIPSNO)
ncCR85
```

```{r, echo=TRUE, warning=TRUE, out.width='90%', fig.align='center', width=7, height=4}
plot(st_geometry(nc), border="grey")
plot(ncCR85, st_centroid(st_geometry(nc), of_largest_polygon), add=TRUE, col="blue")
```
Now generate a random variable. Here I've set the seed - maybe choose your own, and compare outcomes with the people around you. With many people in the room, about 5 in 100 may get a draw that is autocorrelated when tested with Moran's $I$ (why?).

```{r, echo=TRUE}
set.seed(1)
nc$rand <- rnorm(nrow(nc))
lw <- nb2listw(ncCR85, style="B")
moran.test(nc$rand, listw=lw, alternative="two.sided")
```

Now we'll create a trend (maybe try plotting `LM` to see the trend pattern). Do we get different test outcomes by varying beta and sigma (alpha is constant).

```{r, echo=TRUE}
nc$LM <- as.numeric(interaction(nc$L_id, nc$M_id))
alpha <- 1
beta <- 0.5
sigma <- 2
nc$trend <- alpha + beta*nc$LM + sigma*nc$rand
moran.test(nc$trend, listw=lw, alternative="two.sided")
```
To get back to reality, include the trend in a linear model, and test again. 

```{r, echo=TRUE}
lm.morantest(lm(trend ~ LM, nc), listw=lw, alternative="two.sided")
```

So we can manipulate a missing variable mis-specification to look like spatial autocorrelation. Is this informative?

#### Extra problem (own time after we're done if you like):

Sometimes we only have data on a covariate for aggregates of our units of observation. What happens when we "copy out" these aggregate values to the less aggregated observations? First we'll aggregate `nc` by `LM`, then make a neighbour object for the aggregate units

```{r, echo=TRUE}
aggLM <- aggregate(nc[,"LM"], list(nc$LM), head, n=1)
(aggnb <- poly2nb(aggLM))
```

```{r, echo=TRUE}
plot(st_geometry(aggLM))
```

Next, draw a random sample for the aggregated units:

```{r, echo=TRUE}
set.seed(1)
LMrand <- rnorm(nrow(aggLM))
```

Check that it does not show any spatial autocorrelation:

```{r, echo=TRUE}
moran.test(LMrand, nb2listw(aggnb, style="B"))
```

Copy it out to the full data set, indexing on values of LM; the pattern now looks pretty autocorrelated

```{r, echo=TRUE}
nc$LMrand <- LMrand[match(nc$LM, aggLM$LM)]
plot(nc[,"LMrand"])
```

which it is:

```{r, echo=TRUE}
moran.test(nc$LMrand, listw=lw, alternative="two.sided")
```

We've manipulated ourselves into a situation with abundant spatial autocorrelation at the level of the counties, but only by copying out from a more aggregated level. What is going on?

## Raster data 

Spatial raster data is observed using rectangular (often square) cells, within which attribute data are observed. Raster data are very rarely object-based, very often they are field-based and could have been observed everywhere. We probably do not know where within the raster cell the observed value is correct; all we know is that at the chosen resolution, this is the value representing the whole cell area.


```{r, echo = TRUE, cache=TRUE}
library(elevatr)
elevation <- get_elev_raster(as(byb, "Spatial"), z = 14)
```

```{r, echo = TRUE, eval=FALSE}
mapview(elevation, col=terrain.colors)
```


### Representing spatial raster data in R (**sp** and **raster**)


The **raster** package S4 representation builds on the **sp** representation, using a `GridTopology` S4 object to specify the grid, and a data frame to hold the data. **raster** defines `RasterLayer`, and combinations of layers as stacks (may be different storage classes) or bricks (same storage class - array). Adding time remains an issue; **raster** can avoid reading data into memory using **rgdal** mechanisms.


```{r, echo = TRUE}
elevation
```


```{r, echo = TRUE}
sp::gridparameters(as(elevation, "SpatialGrid"))
```


```{r, echo = TRUE}
e1 <- st_as_stars(elevation)
e1
```

